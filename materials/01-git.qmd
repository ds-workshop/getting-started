---
format:
  revealjs:
    slide-number: true
    width: 1600
    height: 900
    css: ["theme/theme.css"]
    theme: simple
    echo: false
    fig-align: center
    fig-height: 6
    fig-width: 10
    fig-dpi: 400
editor: source
---

```{r}
#| label: setup
#| include: false

library(tidyverse)
library(tidytext)
library(ggthemes)
library(countdown)
library(bggUtils)
library(sentimentr)

# set ggplot theme
theme_set(
  bggUtils::theme_bgg()+
    theme(strip.text.x = element_text(size = 12)
    )
)

knitr::opts_chunk$set(
  comment = '#>', fig.width = 6, fig.height = 6
)

countdown_timer <- function(
    minutes = 1, 
    play_sound = TRUE, 
    font_size = "2em", 
    ...
) {
  countdown(
    minutes = minutes,
    # Fanfare when it's over
    play_sound = play_sound,
    # Set timer theme to match solarized colors
    color_border              = "#404041",
    color_text                = "white",
    color_background = "#447099",
    color_running_background  = "#72994E",
    color_running_text        = "white",
    color_finished_background = "#EE6331",
    color_finished_text       = "white",
    font_size = font_size,
    ...
  )
}
```


# Getting to Know <br> Git and GitHub {
background-image="images/dont_panic.png" 
background-size="contain" 
background-position="right" 
background-color="black"
background-opacity=0.75}

## The Problem

::: {.incremental}

Consider the following situations:

- We've been working on a project for ages. We've gone through about 30 different iterations of writing a function and keep going back and forth on which approach we want to keep.

- We made a change to one of the core functions of our project and everything seemed to be great. But two weeks later we discovered a change to a helper function broke something in our monthly report. We're now trying to figure out what we changed and how to patch it.

- Someone recently mentioned that lightgbm + linear trees offers a really nice improvement in both training time and performance over XGBoost. They want to test it in our project, and then evaluate whether this should become the new model. 

:::

## Version Control

For each one of these scenarios, we intuitively wanted something resembling version control. We want to tinker with making a change, but we don't want that change to overrwite or break our existing code. 

. . .

[So we make a copy of the original, then create a new copy that we begin to edit and work on without breaking the original source.]{.fragment .highlight-red}

. . .

We've all probably come up with some version of crazy, half-baked version syntax to control the various versions of projects/files. 

. . . 

## So why Git?

. . .

If you're like me, at some point you thought to yourself, maybe I could be that guy who uses Git and talks about **commits** and **pull requests** and really knows what he's doing with dev vs prod environments rather than just putting **\_dev** and **\_test** at the end of important files.

. . . 

I'm going to *improve*.

. . .

I'm going to be more than I've ever been.

. . .

I'm going to use Git.

. . .

## 

{{< video https://youtu.be/x_CNqKA2t9M?si=gFjkE4VeObGw_TK2&t=136 >}}

##

And about thirty minutes later it was so unclear how any of this would help you that you just punted and decided to keep working as you always have, warts and all, because Git clearly comes from **The Bad Place**.

. . .

## The Reality

So many of the frustrations with writing code, making changes, and storing the history of your work go away once we implement version control.

. . .

There's a reason Git is used everywhere. It is the life jacket in a sea of stashing files everywhere with poor naming conventions and no lineage or history.

. . .


You have to learn how to use Git.

. . .


It's going to be painful.


. . .



[But it's worth it.]{style="font-size: 100px;"}


## Why should we *commit* to this?

. . .

From [Excuse Me, Do You Have a Moment to Talk About Version Control by Jennifer Bryan:](https://www.tandfonline.com/doi/full/10.1080/00031305.2017.1399928)

. . .

> Why would a statistician use a version control system, such as Git? And what is the point of hosting your work online, e.g., on GitHub? Could the gains possibly justify the inevitable pain?
**I say yes, with the zeal of the converted.**

. . .

> Doing your work becomes tightly integrated with organizing, recording, and disseminating it. It’s not a separate, burdensome task you are tempted to neglect.

. . .

> Collaboration is much more structured, with powerful tools for asynchronous work and managing versions.

. . .

> By using common mechanics across work modes (research, teaching, analysis), you achieve basic competence quickly and avoid the demoralizing forget-relearn cycle.

## 

Despite this zeal, she does make an important note:

. . .

> Now the bad news: Git was built neither for the exact usage described here, nor for broad usability. You will undoubtedly notice this, so it’s best to know in advance.

. . .

Git was not designed for data science projects. This will at times create slightly wonky implementations and workarounds that feel frustrating. 

. . .

Things get more complicated once we start trying to version control data/models, which is a whole topic in and of itself.


# With and Without Git: <br> An Example {
background-image="images/starwars_luke.jpeg" 
background-size="contain" 
background-position="right" 
background-color="black"
background-opacity=0.75}

## Was Luke Really That Whiny?

. . .

Suppose we have a project we are working on. We are interested in running text/sentiment analysis on the scripts of the original Star Wars trilogy. 
. . .

We want to know things such as, who are the most positive/negative characters in A New Hope? A lot of people have claimed Luke was really whiny; is that the case?

. . .

##

So, naturally, we go and get the script from A New Hope in text form. 

. . .

```{r load and look at star wars text}
#| echo: true
#| eval: true
#| message: false
#| warning: false
#| label: starwars-dialogue

clean_starwars = function(data) {
  
  data |>
    mutate(episode = case_when(document == 'a new hope' ~ 'iv',
                               document == 'the empire strikes back' ~ 'v',
                               document == 'return of the jedi' ~ 'vi')) |>
    mutate(character = case_when(character == 'BERU' ~ 'AUNT BERU',
                                 character == 'LURE' ~ 'LUKE',
                                 TRUE ~ character)) |>
    select(episode, everything())
}

# load starwars
starwars = read_csv(here::here('materials', 'data', 'starwars_text.csv'))  |>
  clean_starwars()

# show first few lines of a new hope
starwars |>
  head(10) |>
  select(episode, document, character, dialogue) 

```

##

We tokenize the data, remove stopwords, and then calculate sentiment in a pretty simple way.

. . .

```{r}
#| echo: true
#| eval: true
#| message: false
#| warning: false
#| label: starwars-text

data("stop_words")

starwars_tokenized =
  starwars |>
  unnest_tokens(word, dialogue) |>
  anti_join(stop_words, by = "word")

starwars_tokenized |>
  inner_join(tidytext::get_sentiments("afinn"), by = "word")

```

## 

We then calculate sentiment across all characters to get a sense of how negative Luke really was.

. . .

```{r}
#| fig-align: center
#| fig-height: 6
#| fig-width: 10
#| fig-dpi: 300

starwars_tokenized |>
  filter(document == 'a new hope') |>
  inner_join(get_sentiments("afinn"), by = "word") |>
  group_by(document, character) %>%
  summarize(sentiment = sum(value), .groups = 'drop') |>
  ggplot(aes(y=reorder(character, sentiment), x=sentiment, fill = sentiment))+
  geom_col()+
  scale_fill_gradient2_tableau(limits=c(-5, 2), oob = scales::squish)+
  guides(fill = guide_colourbar(title = "sentiment",
                                title.position = "top",
                                barwidth=8,
                                barheight=0.5))+
  ylab("character")+
  xlab("sentiment score")+
  facet_wrap(document~.)

```

##

Apparently, pretty negative. Let's look at some dialogue.

```{r}
starwars_tokenized |>
  filter(document == 'a new hope') |>
  filter(character == 'LUKE') |>
  inner_join(get_sentiments("afinn"), by = "word") |>
  group_by(document, character, line_number) |>
  summarize(value = sum(value),
            .groups = 'drop') |>
  left_join(
    starwars,
    by = join_by(document, character, line_number)
  ) |>
  arrange(value) |>
  head(20) |>
  select(document, character, line_number, value, dialogue) |>
  group_by(document) |>
  gt::gt()
```


##

This is interesting enough, so we save the script, that produces this analysis, called **sentiment.R**.

. . .

Then we think, maybe we should see what happens if we calculate sentiment in a different way. Were Han and Ben really that negative? Even simple methods of sentiment can vary quite a bit depending on which lexicon you use, so we should try a couple.

. . .

##

But we might want to stick our first approach, so we decide to write a whole new section to our code, or just add a new script entirely, **sentiment_bing.R**.

. . .

```{r}
#| fig-align: center
#| fig-height: 6
#| fig-width: 10
#| fig-dpi: 300

starwars_tokenized |>
  filter(document == 'a new hope') |>
  inner_join(get_sentiments("bing"), by = "word") |>
  count(document, character, line_number, index = line_number %/% 8, sentiment) |>
  arrange(index) |>
  group_by(document, character, sentiment) |>
  summarize(value = sum(n),
            .groups = 'drop') |>
  pivot_wider(names_from = c("sentiment"),
              values_from = c("value"),
              values_fill = 0) |>
  mutate(sentiment = positive - negative) |>
  ggplot(aes(y=reorder(character, sentiment), x=sentiment, fill = sentiment))+
  geom_col()+
  scale_fill_gradient2_tableau(limits=c(-5, 2), oob = scales::squish)+
  guides(fill = guide_colourbar(title = "sentiment",
                                title.position = "top",
                                barwidth=8,
                                barheight=0.5))+
  ylab("character")+
  xlab("sentiment score")+
  facet_wrap(document~.)

```

## 

We get a pretty similar result, so we're feeling okay about ourselves and less okay about Luke.

. . .

But then someone says, we shouldn't rely on such crude methods for calculating sentiment. We should use a more sophisticated method, via the *sentimentr* package.

. . .

So we want to edit our original **sentiment.R** script and switch over to using this new package. This one forces us to add some new packages, and rewrite some of our visualization scripts to get the same type of visualization, so we create a new script, **sentiment_algorithm.R**.

##

We're also slightly worried that we've forgotten what we originally started with, so we're gonna make a **sentiment_original.R** file. Just so we have it.

. . .

But anyway, we'll edit our code for the third time and run it again.

```{r}
#| fig-align: center
#| fig-height: 6
#| fig-width: 10
#| fig-dpi: 300

starwars_sentimentr = 
  starwars |>
  get_sentences() |> 
  sentiment_by(by = c('document', 'character', 'line_number')) |>
  sentimentr::uncombine()

starwars_sentimentr_summarized = 
  starwars_sentimentr |>
  group_by(document, character) |>
  summarize(
    word_count = sum(word_count, na.rm = T),
    sum_sentiment = sum(sentiment, na.rm = T),
    avg_sentiment = mean(sentiment, na.rm = T),
    .groups = 'drop'
  )

starwars_sentimentr_summarized |>
  filter(document == 'a new hope') |>
  slice_max(word_count, n = 40) |>
  ggplot(
    aes(
      x=sum_sentiment,
      y=reorder(character, sum_sentiment),
      fill = sum_sentiment
    )
  )+
  geom_col()+
  scale_fill_gradient2_tableau(limits=c(-5, 2), oob = scales::squish)+
  guides(fill = guide_colourbar(title = "sentiment",
                                title.position = "top",
                                barwidth=8,
                                barheight=0.5))+
  ylab("character")+
  xlab("sentiment score")+
  facet_wrap(document~.)

```


##

This gives us very different results, so we really need to dive into the data bit here to figure out what's going on.

. . .

We decide to compare how our original method (left) calculates sentiment for the entire script of A New Hope compared to **sentimentr** (right). That means we need to go add a visualization to each of our original scripts, so we go edit **sentiment_original.R** and **sentiment_algorithm.R**.

. . .

:::: {.columns}

::: {.column width="50%"}

![](images/ep4_sentiment_by_line_1.png){fig-align="center"}
:::

::: {.column width="50%"}

![](images/ep4_sentiment_by_line_3.png){fig-align="center"}

:::
:::

## 

These are very different, so now we go down a rabbit hole of digging into what we're getting out of the **sentimentr** package. We take a look at Luke's dialogue line by line.

. . .

```{r}
#| fig-align: center
#| fig-height: 6
#| fig-width: 10
#| fig-dpi: 300
#| message: false
#| warning: false

plot_character_lines_with_sentiment = function(data,
                                               character,
                                               cutoff = .35,
                                               ncol = 2) {
  
  data |>
    group_by(episode, document, character) |>
    arrange(line_number) |>
    mutate(row_number = row_number()) |>
    mutate(dialogue = as.character(dialogue)) |>
    mutate(show= case_when(abs(sentiment) > cutoff ~ dialogue,
                           TRUE ~ "")) |>
    mutate(run_sentiment = cumsum(sentiment)) |>
    ggplot(aes(x=row_number, y=run_sentiment, color = sentiment, label = show)) +
    geom_step()+
  #  geom_point(size = 0.5) +
    ggrepel::geom_label_repel(size=2.5, max.overlaps=30)+
    facet_wrap(episode + document+character~.,
               ncol = ncol)+
    xlab("line_number")+
    ylab("running total of sentiment")+
    guides(color = 'none')+
    scale_color_gradient2_tableau(oob = scales::squish)
  
}

starwars_sentimentr |>
  filter(document == 'a new hope') |>
  filter(character == 'LUKE') |>
  plot_character_lines_with_sentiment()

```

##

```{r}
#| fig-align: center
#| fig-height: 6
#| fig-width: 10
#| fig-dpi: 300
#| message: false
#| warning: false


starwars_sentimentr |>
  filter(document == 'the empire strikes back') |>
  filter(character == 'LUKE') |>
  plot_character_lines_with_sentiment()

```

## 

```{r}
#| fig-align: center
#| fig-height: 6
#| fig-width: 10
#| fig-dpi: 300
#| message: false
#| warning: false


starwars_sentimentr |>
  filter(document == 'return of the jedi') |>
  filter(character == 'LUKE') |>
  plot_character_lines_with_sentiment()

```

##

```{r}
#| fig-align: center
#| fig-height: 6
#| fig-width: 10
#| fig-dpi: 400
#| message: false
#| warning: false


starwars_sentimentr |>
  filter(document == 'return of the jedi') |>
  filter(character == 'EMPEROR') |>
  plot_character_lines_with_sentiment()

```

##

We realize that we shouldn't be calculating sentiment at the line-level and then aggregating, because short positive statements potentially end up getting as much weight as longer complaints.

With this method we really should look at the estimated sentiment across a character's entire dialogue to get a sense of their tone.

##

So we implement a change, shifting away from aggregation by summing to using the average sentiment over all lines. We then calculate the estimated sentiment across all characters.

. . .

```{r}
#| fig-align: center
#| fig-height: 6
#| fig-width: 10
#| fig-dpi: 300
#| message: false
#| warning: false

plot_avg_sentiment = function(data,
                              by = c("episode", "document", "character"),
                              top_n = 30, 
                              ncol = 2,
                              scales = "free_x") {
  
  data |>
    get_sentences() |>
    sentiment_by(by = by) |>
    group_by(episode, document) |>
    slice_max(order_by = word_count,
              n = top_n) |>
    ggplot(aes(x=reorder_within(character, ave_sentiment, document),
               y=ave_sentiment,
               color = ave_sentiment,
               ymin = ave_sentiment - 1.96 * sd,
               ymax = ave_sentiment + 1.96*sd))+
    geom_point(aes(size = word_count))+
    geom_pointrange()+
    coord_flip()+
    facet_wrap(episode +document ~., ncol = ncol,
               scales = scales)+
    scale_color_gradient2_tableau(oob = scales::squish)+
    guides(color = 'none')+
    xlab('character')+
    theme(panel.grid.major = element_blank(),
          legend.title = element_text(size = 10))+
    geom_hline(yintercept = 0, linetype = 'dotted')+
    scale_x_reordered()
  
}

starwars |>
  filter(document == 'a new hope') |>
  plot_avg_sentiment(
    top_n = 30,
    scales = "free_y"
  )

```

##

Is Luke whiny? Well, it depends. [This is the type of hard hitting analysis that I deliver for my clients.]{.fragment}

. . .

```{r}
#| fig-align: center
#| fig-height: 6
#| fig-width: 10
#| fig-dpi: 300
#| message: false
#| warning: false

starwars |>
  filter(character %in% c('LUKE', 'HAN', 'LEIA')) |>
  plot_avg_sentiment(
    top_n = 30,
    scales = "free_y",
    ncol = 1
  )+
  guides(color = 'none')

```


##

What we are left with after a fairly simple analyses is a messy, entangled set of files with absolutely no sense of history or organization.

. . .

![](images/starwars_no_vc.png){fig-align="center"}

. . .

##

This is a mess for us to figure out, imagine if someone else is supposed to come along and work with this code. Where do they start?

## 

How would this look if we were using Git?

The end result is a bit cleaner. We basically just have the one script to worry about. If we're really curious about what we need to do, we check the README (yes, you are expected to read these).

![](images/starwars_folder.png){fig-align="center"}

##

The end result of our work is the **current state** of the project, which we store in a **repository**.

![](images/starwars_repo.png){fig-align="center"}

##

If we want to see the work that we did up to this point, all we have to do is look at the history of that script and the various changes, or **commits**, we made to it.

![](images/starwars_commits.png){fig-align="center"}

## 

This allows us to easily view how our script changed as we worked on it.

![](images/starwars_compare.png){fig-align="center"}

[Click to go to repo](https://github.com/phenrickson/starwars)

##

And, most importantly, we can view the history of our work in the approriate way...

. . .


[The Best and Only Way to View Your Project History](https://starlogs.dev/phenrickson/starwars){style="font-size: 120px;"}

## Why Go Through This Exercise

In short, git is tremendously helpful even just for one individual.

. . .

It removes the mental baggage of editing your code while trying to preserve a history of your work.

. . .

Where it starts to get even more helpful is for enabling collaboration within a team.

. . .

But in order to do that, we need to get comfortable with a few terms and concepts.

# What We Need to Know About Git

## So, what the heck is Git?

## Git Terms

:::: {.columns}

::: {.column width="40%"}

:::{.fragment fragment-index=1}
- Repository: A directory in which file history is preserved
:::

:::{.fragment fragment-index=2}
- Clone: Downloading an existing repository
:::

:::

::: {.column width="50%"}

::: {.fragment fragment-index=1}
![](images/git-repository.png){fig-align="center"}
:::

::: {.fragment fragment-index=2}
![](images/git-clone.png){fig-align="center"}
:::
:::
::::

## Next Steps

- Local: “on your personal machine”
- Remote: “on the official server”
- Branch: A version of the directory
- Commit: A change made to a version of the directory
- Push: Uploads your work to the ‘official’ remote server
- Fetch/Pull: Checks for available updates on a remote
- Switch/Checkout: Switches your local copy to a version of the directory
- Pull Request: A request to merge one branch into another


# Demo

- Cloning a repo
- Viewing repo organization
- Fetch/pull


Cloning
Updating submodules
Repo log
Working tree changes
Fetch / Pull
SHAs
Ref browser
Comparing between branches / commits
Switching between branches / commits

# 

```{mermaid}
graph TD;

A[Remote Repo] --> B[Local Repo]



```

##

```{mermaid}
graph TD;

A[Main Branch] --> B1[Jim's Feature Branch]
A --> B2[Phil's Feature Branch]
B1 --> C1{Work on Feature}
B2 --> C2{Work on Feature}
C1 --> D1[Commit Changes]
C2 --> D2[Commit Changes]
D1 --> E1[Push Changes to Jim's Feature Branch]
D2 --> E2[Push Changes to Phil's Feature Branch]
E1 --> F1[Create Pull Request]
E2 --> F2[Create Pull Request]
F1 --> G1[Review Code]
F2 --> G2[Review Code]
G1 --> H1[Approve Changes]
G2 --> H2[Approve Changes]
H1 --> I1[Merge Pull Request]
H2 --> I2[Merge Pull Request]
I1 --> J1[Delete Jim's Feature Branch]
I2 --> J2[Delete Phil's Feature Branch]

```


# Github and RStudio

## Cloning a Repo

- Connect to 

# `r fontawesome::fa("laptop-code", "white")` Your Turn {background-color="#447099" transition="slide-in"}

- Go to 
-   Try <kbd>`Ctrl + space`</kbd> to see the available YAML options
-   Try out the tab-completion of any options you remember

```{R}
#| echo: false
countdown_timer(10)
```